/*
Copyright Â© 2025 Brevis Network
*/
package cmd

import (
	"context"
	"fmt"
	"log"
	"math/big"
	"time"
	"tools/bindings"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

type ChainConfig struct {
	ChainID          uint64 `mapstructure:"chain_id"`
	ChainRpc         string `mapstructure:"chain_rpc"`
	BrevisMarketAddr string `mapstructure:"brevis_market_addr"`
	StakingTokenAddr string `mapstructure:"staking_token_addr"`

	Keystore   string `mapstructure:"keystore"`
	Passphrase string `mapstructure:"passphrase"`
}

const (
	FlagChainConfig        = "chain-config"
	FlagNonce              = "nonce"
	FlagVk                 = "vk"
	FlagPublicValuesDigest = "public-values-digest"
	FlagImgUrl             = "img-url"
	FlagInputData          = "input-data"
	FlagInputUrl           = "input-url"
	FlagMaxFee             = "max-fee"
	FlagMinStake           = "min-stake"
	FlagDeadline           = "deadline"
)

var (
	chainConfig                 string
	nonce                       uint64
	vk, publicValuesDigest      string
	imgUrl, inputUrl, inputData string
	fee, minStake               string
	deadline                    uint64
)

func RequestProofCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "request-proof",
		Short: "interact with BrevisMarket contract to initiate a proof request",
		RunE: func(cmd *cobra.Command, args []string) error {
			return requestProof()
		},
	}
	cmd.Flags().StringVar(&chainConfig, FlagChainConfig, "", "chain config file path")
	cmd.Flags().Uint64Var(&nonce, FlagNonce, 0, "A unique num to identify a request")
	cmd.Flags().StringVar(&vk, FlagVk, "", "the VK digest that is generated by the build ELF file")
	cmd.Flags().StringVar(&publicValuesDigest, FlagPublicValuesDigest, "", "the public values digest that is generated by the build ELF file and input data")
	cmd.Flags().StringVar(&imgUrl, FlagImgUrl, "", "a public URL of the generated ELF file")
	cmd.Flags().StringVar(&inputData, FlagInputData, "", "the input data that is build by the pico-sdk emulator builder, input 0x if inputURL is provided")
	cmd.Flags().StringVar(&inputUrl, FlagInputUrl, "", "a public URL of a encoded file of the input data, can be empty if the input data is provided")
	cmd.Flags().StringVar(&fee, FlagMaxFee, "", "the max fee to pay for the proving task")
	cmd.Flags().StringVar(&minStake, FlagMinStake, "", "only the provers that stake more than the value can bid for the request")
	cmd.Flags().Uint64Var(&deadline, FlagDeadline, 0, "the proof should be submitted no later than")

	cmd.MarkFlagRequired(FlagChainConfig)
	cmd.MarkFlagRequired(FlagNonce)
	cmd.MarkFlagRequired(FlagVk)
	cmd.MarkFlagRequired(FlagPublicValuesDigest)
	cmd.MarkFlagRequired(FlagImgUrl)
	cmd.MarkFlagRequired(FlagMaxFee)
	cmd.MarkFlagRequired(FlagMinStake)
	cmd.MarkFlagRequired(FlagDeadline)
	return cmd
}

func init() {
	rootCmd.AddCommand(RequestProofCmd())
}

func requestProof() error {
	if (inputData == "0x" || inputData == "") && inputUrl == "" {
		return fmt.Errorf("should provide ether inputData or inputUrl")
	}

	feeInt, success := big.NewInt(0).SetString(fee, 0)
	if !success {
		return fmt.Errorf("fee is not valid")
	}
	minStakeInt, success := big.NewInt(0).SetString(minStake, 0)
	if !success {
		return fmt.Errorf("minStake is not valid")
	}
	if deadline <= uint64(time.Now().Unix()) {
		return fmt.Errorf("deadline should be a future time")
	}

	viper.SetConfigFile(chainConfig)
	err := viper.ReadInConfig()
	chkErr(err, "ReadInConfig")

	var c ChainConfig
	err = viper.UnmarshalKey("chain", &c)
	chkErr(err, "UnmarshalKey")

	ec, err := ethclient.Dial(c.ChainRpc)
	chkErr(err, "Dial")
	chid, err := ec.ChainID(context.Background())
	chkErr(err, "ChainID")
	if chid.Uint64() != c.ChainID {
		return fmt.Errorf("chainid mismatch! cfg has %d but onchain has %d", c.ChainID, chid.Uint64())
	}

	auth, _, err := CreateTransactOpts(c.Keystore, c.Passphrase, chid)
	chkErr(err, "CreateTransactOpts")
	stakingToken, err := bindings.NewIERC20(common.HexToAddress(c.StakingTokenAddr), ec)
	chkErr(err, "NewIERC20")
	brevisMarket, err := bindings.NewBrevisMarket(common.HexToAddress(c.BrevisMarketAddr), ec)
	chkErr(err, "NewBrevisMarket")

	tx, err := stakingToken.Approve(auth, common.HexToAddress(c.BrevisMarketAddr), feeInt)
	chkErr(err, "Approve")
	log.Println("approve tx:", tx.Hash())
	receipt, err := bind.WaitMined(context.Background(), ec, tx)
	chkErr(err, "waitmined")
	if receipt.Status != types.ReceiptStatusSuccessful {
		log.Fatalln("approve tx status is not success")
	}

	tx, err = brevisMarket.RequestProof(auth, bindings.IBrevisMarketProofRequest{
		Nonce:              nonce,
		Vk:                 common.HexToHash(vk),
		PublicValuesDigest: common.HexToHash(publicValuesDigest),
		ImgURL:             imgUrl,
		InputData:          common.FromHex(inputData),
		InputURL:           inputUrl,
		Fee: bindings.IBrevisMarketFeeParams{
			MaxFee:   feeInt,
			MinStake: minStakeInt,
			Deadline: deadline,
		},
	})
	chkErr(err, "RequestProof")
	log.Println("RequestProof tx:", tx.Hash())
	receipt, err = bind.WaitMined(context.Background(), ec, tx)
	chkErr(err, "waitmined")
	if receipt.Status != types.ReceiptStatusSuccessful {
		log.Fatalln("RequestProof tx status is not success")
	}

	return nil
}
